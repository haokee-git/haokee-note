## 素数

首先，对于两个相邻的质数 $a$ 和 $b$，在 $[a,b)$ 内的所有数的 $\cfrac{1}{u(i)v(i)}$ 都是 $\cfrac{1}{ab}$，而这个区间内一共有 $b-a$ 个数，因此这一段区间对答案的贡献为 $\cfrac{b-a}{ab}$。

不难发现这个式子特别像小学数学学过的裂项，可以变成 $\cfrac{1}{a}-\cfrac{1}{b}$。那么，如果有多个区间拼起来，如 ${} \cfrac{b-a}{ab}+\cfrac{c-b}{bc}+\cdots+\cfrac{z-y}{yz} {}$，最后又会变成什么呢？中间的项将会全部消掉，因此只剩下了 $\cfrac{1}{a}-\cfrac{1}{z}$。

因此对于询问 $n$，我们可以找到小于等于 $n$ 的最大质数 $p$，此时 $[2,p)$ 内的数对答案的贡献就是 $\cfrac{1}{2}-\cfrac{1}{p}$ 了。但是我们还有一段 $[p,n]$ 的贡献没有考虑。若大于 $n$ 的下一个质数为 $r$，那么这一段内单个元素的贡献就为 $\cfrac{1}{pr}$，总共贡献 $\cfrac{r-n+1}{pr}$。因此我们只需要进行分数加减运算就行了。

- [!] 注意像我这种暴力同分相加再约分的，需要开 $128$ 位整数。

由于 $10^9$ 范围内质数的个数大约为 $5\times 10^7$，因此寻找上、下一个质数的速度都是很快的，暴力根号判别即可。

```cpp
#include <fstream>

using namespace std;
using LL = long long;

ifstream cin("prime.in");
ofstream cout("prime.out");

LL t, n, prv, nxt;

bool isPrime(LL n) {
  for (LL i = 2; i * i <= n; i++) {
    if (n % i == 0) {
      return 0;
    }
  }
  return 1;
}

__int128_t gcd(__int128_t a, __int128_t b) {
  return !b ? a : gcd(b, a % b);
}

void add(__int128_t &a, __int128_t &b, LL c, LL d) {
  LL g = gcd(c, d);
  c /= g;
  d /= g;
  a = a * d + c * b;
  b = b * d;
  if (!a) {
    b = 1;
    return;
  }
  g = gcd(a, b);
  a /= g;
  b /= g;
}

int main() {
  cin.tie(0)->sync_with_stdio(0);
  for (cin >> t; t; t--) {
    cin >> n;
    for (prv = n; !isPrime(prv); prv--) { }
    for (nxt = n + 1; !isPrime(nxt); nxt++) { }
    __int128_t a = 1, b = 2;
    add(a, b, -1, prv);
    add(a, b, n - prv + 1, nxt * prv);
    cout << (LL)a << '/' << (LL)b << '\n';
  }
  return 0;
}
```

## 秘密通道

首先打开窗口一定是要用的，否则完全没必要打开。因此对于一个格子，它除了可以上下左右移动以外，还可以对于上下左右的方向，选择两个方向打开窗口，往其中一个地方走过去传送，这个可以通过 $4\times 4$ 枚举实现。

状态的话，起点唯一，因此到一个地方肯定是代价越小越好。

- [n] 这时我们就觉得可能会挂，原因是传送之后不一定需要开两个窗口，只需要往其中一个地方开窗口然后用上次传送过来的那个窗口传送。不过实际上可以看作往那个窗口再次放置窗口，然而比赛时的我完全没有想这么多因此就进行了特殊处理，还增加了一个 0/1 状态（是否刚传送）。这是很明显的状态冗余。

于是思路就很清晰了。

1. 预处理每个点往四个方向分别能打到哪些地方；
2. 跑 bfs，两种移动方式：
      - 往相邻各自走；
      - 选择一个方向放置传送门并走过去传送，选择另一个方向作为传送终点
3. 输出答案

- [!] 对于第二种移动方式，增加的代价不一定为 $1$，因此需要使用优先队列而非普通队列进行 BFS。我就是这个挂成了 $60$ 分（`push` 过多导致 MLE）。

```cpp
#include <fstream>
#include <utility>
#include <queue>

using namespace std;

const int kMaxN = 505, kD[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

ifstream cin("portal.in");
ofstream cout("portal.out");

struct Node {
  int x, y, d;

  Node(int x, int y, int d):
    x(x), y(y), d(d) { }

  friend bool operator<(const Node &a, const Node &b) {
    return a.d > b.d;
  }
};

int d[kMaxN][kMaxN], f[kMaxN][kMaxN], n, m, sx, sy, ex, ey;
pair<int, int> p[kMaxN][kMaxN][4];
priority_queue<Node> q;
char a[kMaxN][kMaxN];

void record(int x, int y, int dis) {
  if (x < 1 || x > n || y < 1 || y > m || a[x][y] == '#' || dis >= d[x][y]) {
    return;
  }
  d[x][y] = dis;
  q.emplace(x, y, dis);
}

int calc(int x, int y, const pair<int, int> &p) {
  return abs(x - p.first) + abs(y - p.second);
}

void bfs(int x, int y) {
  fill(d[0], d[0] + kMaxN * kMaxN, 1e9);
  for (q.emplace(x, y, 0), d[x][y] = 0; q.size(); q.pop()) {
    auto t = q.top();
    if (f[t.x][t.y]) {
      continue;
    }
    f[t.x][t.y] = 1;
    for (auto i : kD) {
      record(t.x + i[0], t.y + i[1], d[t.x][t.y] + 1);
    }
    for (int i = 0; i < 4; i++) {
      for (int j = 0; j < 4; j++) {
        record(p[t.x][t.y][j].first, p[t.x][t.y][j].second, d[t.x][t.y] + calc(t.x, t.y, p[t.x][t.y][i]) + 1);
      }
    }
  }
}

int main() {
  cin.tie(0)->sync_with_stdio(0);
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      cin >> a[i][j];
      if (a[i][j] == 'C') {
        sx = i, sy = j;
      } else if (a[i][j] == 'F') {
        ex = i, ey = j;
      }
    }
  }
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      if (a[i][j] == '#') {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int x = i, y = j;
        for (; a[x][y] != '#'; x += kD[k][0], y += kD[k][1]) { }
        x -= kD[k][0], y -= kD[k][1];
        p[i][j][k] = {x, y};
      }
    }
  }
  bfs(sx, sy);
  int ans = d[ex][ey];
  cout << (ans != 1e9 ? to_string(ans) : "nemoguce") << '\n';
  return 0;
}
```