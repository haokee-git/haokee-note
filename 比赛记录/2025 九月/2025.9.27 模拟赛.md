## 乘法减法按位或

首先 $\mathcal O(n^2)$ 是非常好想的，但是发现优化很难。观察到值域较小，所以可以想到设 $dp_i$ 表示满足 $a_j|a_k=i$ 最大的 $j\times k$。然而根本不会转移，所以直接趋势。

不过，观察式子中 $i\times j$ 是一个二次项，增长幅度特别快，而 $-k(a_i|a_j)$ 是一次项，当 $i,j$ 过大的时候后面的那一项几乎可以忽略，所以可以猜测答案 $(i,j)$ 肯定在靠后的位置。

严格证明如下：

- [n] 假设 $(n-1,n)$ 是最终最大的，那么我们需要推翻这个结论的话一定会有一个更大的。设更大的为 $(i,n)$，最好情况下该二元组的值为 $in-0=in$，而 $(n-1,n)$ 最坏情况下值为 $n(n-1)-2kn$。所以有方程 $in\ge n(n-1)-2kn$，解得 $i\ge n-2k-1$（也可以不取等），所以我们只需要枚举 $i\in [n-2k-1,n]$ 即可。

时间复杂度 $\mathcal O(kn)$。

```cpp
#include <iostream>

using namespace std;
using LL = long long;

const LL kMaxN = 3e5 + 5;

LL a[kMaxN], t, n, k;

int main() {
  cin.tie(0)->sync_with_stdio(0);
  for (cin >> t; t; t--) {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
      cin >> a[i];
    }
    LL ans = -1e18;
    for (LL i = max(1LL, n - 2 * k - 1); i <= n; i++) {
      for (LL j = 1; j <= n; j++) {
        if (i != j) {
          ans = max(ans, i * j - k * (a[i] | a[j]));
        }
      }
    }
    cout << ans << '\n';
  }
  return 0;
}
```

## 队列

首先，把 $n$ 个同学变成 $n$ 个点，$a$ 要站在 $b$ 前面可以看做 $a$ 往 $b$ 连一条边，那么最后会形成一个图，有多个连通块。如果一个连通块可以满足条件，那么这个连通块是一条链（因为不仅有前后关系还要相邻）。

如何判断每个连通块是否是链？每个点的入度、出度均不超过 $1$，且没有环。判环用拓扑排序即可。注意去重边。去掉重边之后若剩下 $m$ 条边那么连通块数量为 $n-m$，这些连通块彼此之间没有前后关系因此方案数 $(n-m)!$。

时间复杂度 $\mathcal O(n+m)$（去重边我带了个 $\log$）。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>

using namespace std;
using LL = long long;

const LL kMaxN = 2e5 + 5, kMod = 1e9 + 7;

LL id[kMaxN], od[kMaxN], n, m, cnt, sum, ans = 1;
vector<LL> e[kMaxN];
queue<LL> q;

int main() {
  cin.tie(0)->sync_with_stdio(0);
  cin >> n >> m;
  for (LL i = 1, u, v; i <= m; i++) {
    cin >> u >> v;
    e[u].push_back(v);
  }
  for (LL i = 1; i <= n; i++) {
    sort(e[i].begin(), e[i].end());
    e[i].erase(unique(e[i].begin(), e[i].end()), e[i].end());
    od[i] = e[i].size();
    for (int j : e[i]) {
      id[j]++;
    }
  }
  if (count_if(id + 1, id + n + 1, [](LL i) {
    return i > 1;
  }) || count_if(od + 1, od + n + 1, [](LL i) {
    return i > 1;
  })) {
    cout << "0\n";
    return 0;
  }
  for (LL i = 1; i <= n; i++) {
    if (!id[i]) {
      q.push(i);
    }
  }
  for (; q.size(); q.pop()) {
    LL t = q.front();
    cnt++;
    for (LL i : e[t]) {
      if (!--id[i]) {
        q.push(i);
      }
    }
  }
  if (cnt != n) {
    cout << "0\n";
    return 0;
  }
  for (LL i = 1; i <= n; i++) {
    sum += e[i].size();
  }
  sum = n - sum;
  for (LL i = 1; i <= sum; i++) {
    ans = ans * i % kMod;
  }
  cout << ans << '\n';
  return 0;
}
```

## 权值

贡献可以拆为

1. 所有满足条件序列的数量；
2. 每个数的出现次数之和。

首先是第一问，对于长度为 $i$ 且取值范围在 $[1,n]$ 的整数序列，一共有 $n^i$ 种。因此序列数量为 ${} f(n,m)=\sum\limits_{i=0}^m n^i {}$。这是一个等比数列，应用等比数列求和公式得到

$$
f(n,m)=\sum\limits_{i=0}^m n^i=
\begin{cases}
m+1&\text{if}~n=1 \\
\cfrac{n^{m+1}-1}{n-1}&\text{else}
\end{cases}
$$

至于每个数的出现次数之和，由于每个数的地位相等，因此每个数的出现次数之和也相等。对于 $1$，可以采用容斥，用总序列数量减去不使用 $1$ 的序列数量，即

$$
\sum_{i=0}^m n^i-\sum_{i=0}^n (n-1)^i=f(n,m)-f(n-1,m)
$$

再将这个数乘上 $n$ 即可得到所有数的出现次数之和，再加上一类贡献，得到最终答案

$$
f(n,m)+n\times f(n,m)-n\times f(n-1,m)=(n+1)f(n,m)-n\times f(n-1,m)
$$

用快速幂和乘法逆元即可。时间复杂度 $\mathcal O(t(\log_2 m+\log_2 n))$。

```cpp
#include <iostream>

using namespace std;
using LL = long long;

const LL kMod = 1e9 + 7;

LL t, n, m;

LL pow(LL a, LL b) {
  LL res = 1;
  for (; b; b /= 2) {
    b % 2 && (res = res * a % kMod);
    a = a * a % kMod;
  }
  return res;
}

LL solve(LL n, LL m) {
  if (n == 1) {
    return m + 1;
  }
  return (pow(n, m + 1) - 1 + kMod) % kMod * pow(n - 1, kMod - 2) % kMod;
}

int main() {
  cin.tie(0)->sync_with_stdio(0);
  for (cin >> t; t; t--) {
    cin >> n >> m;
    cout << ((n + 1) * solve(n, m) % kMod - n * solve(n - 1, m) % kMod + kMod) % kMod << '\n';
  }
  return 0;
}
```