## 乘法减法按位或

首先 $\mathcal O(n^2)$ 是非常好想的，但是发现优化很难。观察到值域较小，所以可以想到设 $dp_i$ 表示满足 $a_j|a_k=i$ 最大的 $j\times k$。然而根本不会转移，所以直接趋势。

不过，观察式子中 $i\times j$ 是一个二次项，增长幅度特别快，而 $-k(a_i|a_j)$ 是一次项，当 $i,j$ 过大的时候后面的那一项几乎可以忽略，所以可以猜测答案 $(i,j)$ 肯定在靠后的位置。

严格证明如下：

- [n] 假设 $(n-1,n)$ 是最终最大的，那么我们需要推翻这个结论的话一定会有一个更大的。设更大的为 $(i,n)$，最好情况下该二元组的值为 $in-0=in$，而 $(n-1,n)$ 最坏情况下值为 $n(n-1)-2kn$。所以有方程 $in\ge n(n-1)-2kn$，解得 $i\ge n-2k-1$（也可以不取等），所以我们只需要枚举 $i\in [n-2k-1,n]$ 即可。

时间复杂度 $\mathcal O(kn)$。

```cpp
#include <iostream>

using namespace std;
using LL = long long;

const LL kMaxN = 3e5 + 5;

LL a[kMaxN], t, n, k;

int main() {
  cin.tie(0)->sync_with_stdio(0);
  for (cin >> t; t; t--) {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
      cin >> a[i];
    }
    LL ans = -1e18;
    for (LL i = max(1LL, n - 2 * k - 1); i <= n; i++) {
      for (LL j = 1; j <= n; j++) {
        if (i != j) {
          ans = max(ans, i * j - k * (a[i] | a[j]));
        }
      }
    }
    cout << ans << '\n';
  }
  return 0;
}
```