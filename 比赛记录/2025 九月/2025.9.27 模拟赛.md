## 乘法减法按位或

#数学 #结论 #位运算 

首先 $\mathcal O(n^2)$ 是非常好想的，但是发现优化很难。观察到值域较小，所以可以想到设 $dp_i$ 表示满足 $a_j|a_k=i$ 最大的 $j\times k$。然而根本不会转移，所以直接趋势。

不过，观察式子中 $i\times j$ 是一个二次项，增长幅度特别快，而 $-k(a_i|a_j)$ 是一次项，当 $i,j$ 过大的时候后面的那一项几乎可以忽略，所以可以猜测答案 $(i,j)$ 肯定在靠后的位置。

严格证明如下：

- [n] 假设 $(n-1,n)$ 是最终最大的，那么我们需要推翻这个结论的话一定会有一个更大的。设更大的为 $(i,n)$，最好情况下该二元组的值为 $in-0=in$，而 $(n-1,n)$ 最坏情况下值为 $n(n-1)-2kn$。所以有方程 $in\ge n(n-1)-2kn$，解得 $i\ge n-2k-1$（也可以不取等），所以我们只需要枚举 $i\in [n-2k-1,n]$ 即可。

时间复杂度 $\mathcal O(kn)$。

```cpp
#include <iostream>

using namespace std;
using LL = long long;

const LL kMaxN = 3e5 + 5;

LL a[kMaxN], t, n, k;

int main() {
  cin.tie(0)->sync_with_stdio(0);
  for (cin >> t; t; t--) {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
      cin >> a[i];
    }
    LL ans = -1e18;
    for (LL i = max(1LL, n - 2 * k - 1); i <= n; i++) {
      for (LL j = 1; j <= n; j++) {
        if (i != j) {
          ans = max(ans, i * j - k * (a[i] | a[j]));
        }
      }
    }
    cout << ans << '\n';
  }
  return 0;
}
```

## 队列

#数学 

首先，把 $n$ 个同学变成 $n$ 个点，$a$ 要站在 $b$ 前面可以看做 $a$ 往 $b$ 连一条边，那么最后会形成一个图，有多个连通块。如果一个连通块可以满足条件，那么这个连通块是一条链（因为不仅有前后关系还要相邻）。

如何判断每个连通块是否是链？每个点的入度、出度均不超过 $1$，且没有环。判环用拓扑排序即可。注意去重边。去掉重边之后若剩下 $m$ 条边那么连通块数量为 $n-m$，这些连通块彼此之间没有前后关系因此方案数 $(n-m)!$。

时间复杂度 $\mathcal O(n+m)$（去重边我带了个 $\log$）。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>

using namespace std;
using LL = long long;

const LL kMaxN = 2e5 + 5, kMod = 1e9 + 7;

LL id[kMaxN], od[kMaxN], n, m, cnt, sum, ans = 1;
vector<LL> e[kMaxN];
queue<LL> q;

int main() {
  cin.tie(0)->sync_with_stdio(0);
  cin >> n >> m;
  for (LL i = 1, u, v; i <= m; i++) {
    cin >> u >> v;
    e[u].push_back(v);
  }
  for (LL i = 1; i <= n; i++) {
    sort(e[i].begin(), e[i].end());
    e[i].erase(unique(e[i].begin(), e[i].end()), e[i].end());
    od[i] = e[i].size();
    for (int j : e[i]) {
      id[j]++;
    }
  }
  if (count_if(id + 1, id + n + 1, [](LL i) {
    return i > 1;
  }) || count_if(od + 1, od + n + 1, [](LL i) {
    return i > 1;
  })) {
    cout << "0\n";
    return 0;
  }
  for (LL i = 1; i <= n; i++) {
    if (!id[i]) {
      q.push(i);
    }
  }
  for (; q.size(); q.pop()) {
    LL t = q.front();
    cnt++;
    for (LL i : e[t]) {
      if (!--id[i]) {
        q.push(i);
      }
    }
  }
  if (cnt != n) {
    cout << "0\n";
    return 0;
  }
  for (LL i = 1; i <= n; i++) {
    sum += e[i].size();
  }
  sum = n - sum;
  for (LL i = 1; i <= sum; i++) {
    ans = ans * i % kMod;
  }
  cout << ans << '\n';
  return 0;
}
```

## 权值

#数学 #等比数列求和 #快速幂 #乘法逆元 

贡献可以拆为

1. 所有满足条件序列的数量；
2. 每个数的出现次数之和。

首先是第一问，对于长度为 $i$ 且取值范围在 $[1,n]$ 的整数序列，一共有 $n^i$ 种。因此序列数量为 ${} f(n,m)=\sum\limits_{i=0}^m n^i {}$。这是一个等比数列，应用等比数列求和公式得到

$$
f(n,m)=\sum\limits_{i=0}^m n^i=
\begin{cases}
m+1&\text{if}~n=1 \\
\cfrac{n^{m+1}-1}{n-1}&\text{else}
\end{cases}
$$

至于每个数的出现次数之和，由于每个数的地位相等，因此每个数的出现次数之和也相等。对于 $1$，可以采用容斥，用总序列数量减去不使用 $1$ 的序列数量，即

$$
\sum_{i=0}^m n^i-\sum_{i=0}^n (n-1)^i=f(n,m)-f(n-1,m)
$$

再将这个数乘上 $n$ 即可得到所有数的出现次数之和，再加上一类贡献，得到最终答案

$$
f(n,m)+n\times f(n,m)-n\times f(n-1,m)=(n+1)f(n,m)-n\times f(n-1,m)
$$

用快速幂和乘法逆元即可。时间复杂度 $\mathcal O(t(\log_2 m+\log_2 n))$。

```cpp
#include <iostream>

using namespace std;
using LL = long long;

const LL kMod = 1e9 + 7;

LL t, n, m;

LL pow(LL a, LL b) {
  LL res = 1;
  for (; b; b /= 2) {
    b % 2 && (res = res * a % kMod);
    a = a * a % kMod;
  }
  return res;
}

LL solve(LL n, LL m) {
  if (n == 1) {
    return m + 1;
  }
  return (pow(n, m + 1) - 1 + kMod) % kMod * pow(n - 1, kMod - 2) % kMod;
}

int main() {
  cin.tie(0)->sync_with_stdio(0);
  for (cin >> t; t; t--) {
    cin >> n >> m;
    cout << ((n + 1) * solve(n, m) % kMod - n * solve(n - 1, m) % kMod + kMod) % kMod << '\n';
  }
  return 0;
}
```

## 钓鱼

#贪心 #优先队列 

### 20 分

瞎搜就行了。状态就是 $(i,j)$ 表示当前到达第 $i$ 个地点，当前深度为 $j$，然后它可以转移到 $(i+1,j\pm 1)$ 或者 $(i+1,j)$，累加以下贡献就行了。

### 50 分

可以发现上面的算法对于重复状态 $(i,j)$ 在不同时刻结果不一样，但是结果肯定是越大越好，因此采用动态规划，将贡献列为最优化属性。设 $dp_{i,j}$ 表示当前到达第 $i$ 个地点，深度为 $j$ 所可以获得的最大饱腹值，转移方程 $dp_{i,j}=\max(dp_{i-1,j},dp_{i-1,j\pm 1})+j\times(B_i-A_i)$。

### 80 分

想到了 100 分的思路，但是用的是双 $\log$ 实现，或者直接用费用流模拟贪心过程了导致的。

- [b] 赛时被 $\mathcal O(n^2)$ 暴力卡过去了，下次再搞大一点。

### 100 分

假设已经凿完了，我们可以将层数“抽丝剥茧”，把第一层抽下来，然后把第二层抽下来，不难发现第 $K$ 层会完全被包含在第 $K-1$ 层中，而且这两层左端点和右端点一定是不会重合的（因为如果重合了相邻深度差就会大于 $1$）。

因此这道题目可以简化为“区间覆盖”的形式，即进行若干次选择，每次选择 $[L,R]$ 对 $L\sim R$ 的每一个地点都凿深一个单位，并且每个地点都只能作为左端点和作为右端点最多一次。

由于涉及到区间求和，可以整一个前缀和 $P_i=\sum\limits_{j=1}^i(B_j-A_j)$，这样我们选择一个区间的操作就可以简化为选择一前一后两个 $P_i$ 相减。这时候就和买股票那题很像了。

我们枚举右端点 $R$，因为一个点只能最多作为右端点一次，因此我们需要在之前的左端点中找到 $P_{L-1}$ 最小的然后让 $P_R$ 减去 $P_{L-1}$ 进行一次区间覆盖（当然如果结果是负数那就不要做了）。同时由于一个点只能作为左端点一次，因此 $L$ 用完之后就需要把 $L$ 扔掉。

这样不一定是最后的，原因是因为以后可能会有更大的 $P_R$ 来减 $P_{L-1}$ 会更优。但是注意到 $P_k-P_i=(P_k-P_j)+(P_j-P_i)$，也就是说先让 $P_{R}$ 减去 $P_{L-1}$ 之后，遇到后面更大的让它直接减 $P_R$ 而不是 $P_{L-1}$，是和不选 $P_{R}$ 直接让后面的减 $P_{L}$ 是一样的，因此我们只需要把 $P_R$ 额外放进队列，静待后面的 $P$ 减去 $P_R$ “反悔”就行了。最后将 $P_R$ 放入队列，作为以后的左端点。

时间复杂度 $\mathcal O(n\log_2 n)$。

```cpp
#include <iostream>
#include <queue>

using namespace std;
using LL = long long;

const LL kMaxN = 1e6 + 5;

LL p[kMaxN], n, ans;
priority_queue<LL, vector<LL>, greater<>> q;

int main() {
  // 输入并作前缀和
  cin.tie(0)->sync_with_stdio(0);
  cin >> n;
  for (LL i = 1, a, b; i <= n; i++) {
    cin >> a >> b;
    p[i] = p[i - 1] + b - a;
  }

  // 反悔贪心
  q.push(p[0]);
  for (LL i = 1; i <= n; i++) {
    if (p[i] - q.top() > 0) {  // 进行区间覆盖
      ans += p[i] - q.top();
      q.pop();
      q.push(p[i]);            // 留下反悔机会
    }
    q.push(p[i]);
  }
  cout << ans << '\n';
  return 0;
}
```