## 重组字母

#贪心 

> [!note] 思路
> 
> 首先看到字典序最小，我们就可以想到从前往后枚举答案的每一位，然后从小到大枚举字符，找到一个字典序最小、且填上之后后面不会无解的字符填上就行了。
> 
> 如何判断填上之后后面有没有解呢？比较直观的思路是对于后面每个 cch 的字符记录出现次数。对于 $\texttt{a}$ 的出现次数，cwj 在后面 ${} \texttt{b} {}$ 的出现次数和 $\texttt{c}$ 的出现次数之和要超过它。$\texttt{b}$ 和 $\texttt{c}$ 同理。这样就可以做到 $\mathcal O(1)$ 判断了，总时间复杂度 $\mathcal O(n)$。
> 
> 当然也可以往右做模拟。时间复杂度 $\mathcal O(n^2)$，在本题当中同样可以通过。

```cpp
int cnt[128], f[128], n;
string s, t, ans;

bool check(char c) {
  if (cnt['b'] + cnt['c'] >= f['a'] &&
      cnt['a'] + cnt['b'] >= f['c'] &&
      cnt['a'] + cnt['c'] >= f['b']) {
    return 1;
  }
  return 0;
}

int main() {
  cin >> n >> s >> t;
  for (char c : s) {
    cnt[c]++;
  }
  for (char c : t) {
    f[c]++;
  }
  for (char i : t) {
    for (char j = 'a'; j <= 'c'; j++) {
      if (i == j) {
        continue;
      }
      if (cnt[j]) {
        cnt[j]--;
        f[i]--;
        if (check(j)) {
          ans += j;
          break;
        }
        cnt[j]++;
        f[i]++;
      }
    }
  }
  cout << ans << '\n';
  return 0;
}
```

## 区间整除

#数学 #质数 #质因数分解 

> [!note] 思路
> 
> > [!important] 注意
> > 
> > 以下记 $f(l,r)=\prod\limits_{i=l}^r i=l\times(l+1)\times\cdots\times r$
> 
> 首先我们看到整除，就可以想到质因数分解。考虑对 $f(a,b)$ 和 $f(c,d)$ 进行质因数分解，等价于对所有 $i\in [a,b]$ 当中 $i$ 进行质因数分解，然后相同质因数的指数相加。
> 
> 对于这种区间的问题，可以想到前缀和。但是由于在 $10^7$ 的范围内大约有 ${} 6\times 10^5$ 个质数，所以导致在 $i$ 较大的时候 $i!$ 的质因数分解底数数量会达到 $6\times 10^5$，当然无法直接保存。
> 
> 考虑离线下来求。现在我们需要面对的问题就是对任意 $i\in \left[1,10^7\right]$ 进行质因数分解了。直接分解单个时间复杂度高达 $\mathcal O\left(\sqrt n\right)$，所以我们需要使用质数筛（$\mathcal O(n\log\log n)$ 或 $\mathcal O(n)$）求出每个数的最大质因子，然后使用单个时间复杂度 $\mathcal O\left(\log n\right)$ 的质因数分解。
> 
> 由于本题值域达到了 $10^7$，$\mathcal O(n\log_2 n)$ 也是吃不消的。考虑转换思路，不专注于每个数的质因数分解，而专注与每个质因子的出现情况。
> 
> 首先有 $f(l,r)=\cfrac{r!}{(l-1)!}$。我们枚举质因子 $i$（$i$ 肯定是质数列表里面的），那么 $f(l,r)$ 当中 $i$ 的出现次数就是 $r!$ 当中 $i$ 的出现次数减去 $(l-1)!$ 当中 $i$ 的出现次数。
> 
> > [!question] 疑问
> > 
> > 如何计算 $n!$ 当中 ${} p$ 作为质因子出现的次数呢？
> 
> > [!success] 计算方法
> > 
> > 枚举 $k$ 计算 $n!$ 当中 $p^k$ 的出现次数，那么出现次数为 $\cfrac{n}{p^k}$，累加起来即可得到 $p$ 作为质因子的出现次数（可能在同一个数当中出现多次）。
> > 
> > 时间复杂度 $\mathcal O(\log p)$。
> 
> 而 $a|b$ 等价于对于任意质因子 $p$ 在 $a$ 当中的出现次数不超过在 $b$ 当中的出现次数。所以，我们只需要枚举质数（质因子），计算他们在 $f(a,b)$ 和 $f(c,d)$ 当中的出现次数，判断是否小于等于即可。
> 
> 时间复杂度 $\mathcal O(n\log\log n+Tm\log n)$，其中 $n$ 为值域，$m$ 为值域中质数数量（大约 $6\times 10^6$。使用线性筛可以将预处理优化到 $\mathcal O(n)$。

```cpp
const LL kMaxN = 1e7 + 5;

LL t, a, b, c, d;
bool p[kMaxN];
vector<LL> v;

void init(LL n) {
  for (LL i = 2; i <= n; i++) {
    if (!p[i]) {
      v.push_back(i);
    }
    for (LL j : v) {
      if (i * j > n) {
        break;
      }
      p[i * j] = 1;
      if (i % j == 0) {
        break;
      }
    }
  }
}

LL calc(LL n, LL p) {
  LL res = 0;
  for (LL x = p; x <= n; x *= p) {
    res += n / x;
  }
  return res;
}

int main() {
  cin.tie(0)->sync_with_stdio(0);
  init(1e7);
  for (cin >> t; t; t--) {
    cin >> a >> b >> c >> d;
    bool ans = 1;
    for (LL i : v) {
      if (i > b && i > d) {
        break;
      }
      LL x1 = calc(b, i) - calc(a - 1, i);
      LL x2 = calc(d, i) - calc(c - 1, i);
      ans &= x1 <= x2;
      if (!ans) {
        break;
      }
    }
    cout << (ans ? "Yes" : "No") << '\n';
  }
  return 0;
}
```

## 擦数游戏

> [!note] 思路
> 
> 

## 逃离

