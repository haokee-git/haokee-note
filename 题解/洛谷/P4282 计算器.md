#高精度

## 思路

大家在刷题时，每一看到高精度就会对这道题视而不见，仿佛很难似的（我也是）。但其实高精度就是我们小学二年级学的竖式，只是代码看起来比较长而已。

### 高精度加法

我们就按照竖式来，各位相加。例如：

```
  2  0  2  3
+ 1  9  8  0
—————————————
  3  9 10  3
```

但这时我们会发现，$2+8$ 等于的是一个大于等于十的数，而一个数位上根本不可能会有多个数。这时，我们就会“进一”。

```
  2  0  2  3
+ 1  9  8  0
—————————————
  4  0  0  3
     ^  ^
```

为了方便，我们就先全部直接向加，最后再处理进位。

---

### 高精度减法

与加法不同，减法是加法的逆运算，当然不能进位，但是我们可以“借位”。

```
  4  0  0  3
- 1  9  8  0
—————————————
  3 -9 -8  3
```

可以看到，有些位置不够减，变成了负数，那么我们就借去左边的数的一份，当成十来使用。

```
  ·  ·
  4  0  0  3
- 1  9  8  0
—————————————
  2  0  2  3
  
 // 注意百位，这里是0，已经减去了个一，再借一位应该是9
```

---

于是，唯一一篇 python 代码横空出世。~~RE 调了半天。~~

## 代码

```python
# python 的单行读入需要注意
n = int(input())
t = [0] + list(map(int, input().split())) # 这里先用int的map存下来，再转成list
a = [0] + list(map(int, input().split())) # 同理
o = str(input())
b = [0] + list(map(int, input().split()))
ans = []  # 先来一个空列表
for i in range(n + 1):  # python的下标也是从0开始
  ans.append(0) # 不断加入元素
if o == '+':  # 先来加法
  for i in range(1, n + 1):  # 直接相加
    ans[i] = a[i] + b[i]
  for i in range(n, 0, -1): # 处理进位，注意这里反向不遍历0
    ans[i - 1] += ans[i] // t[i]  # 下一位的进位
    ans[i] %= t[i]  # 这一位留下来的值
else:
  for i in range(1, n + 1):  # 各位相减
    ans[i] = a[i] - b[i]
  for i in range(n, 0, -1):  # 反向处理借位
    if ans[i] < 0:  # 如果这一位不够
      ans[i - 1] -= 1  # 向前一位借一
      ans[i] += t[i]  # 注意这里要加上当前位的值
for i in range(1, n + 1):  
  print(ans[i], end = ' ')  # 遍历输出
```