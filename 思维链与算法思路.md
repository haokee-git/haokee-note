## 问题转化与公式推导

首先，我们分析蜗牛的送餐过程。设 $D_i$ 为给第 $i$ 位顾客送达外卖的实际时间。

根据题意，从第 $l$ 位顾客开始，送达时间为 $x_l$。
所以，$D_l = x_l$。

对于后续的顾客 $i > l$，蜗牛从第 $i-1$ 位顾客处出发，花费 $t_{i-1}$ 时间到达第 $i$ 位顾客的地址。到达时间为 $D_{i-1} + t_{i-1}$。如果早于 $x_i$，他会等到 $x_i$；否则直接送达。因此，第 $i$ 位顾客的送达时间为：
$$D_i = \max(D_{i-1} + t_{i-1}, x_i)$$

一个送餐任务 $[l, r]$ 被认为是成功的，当且仅当对于所有的 $i \in [l, r]$，都满足 $D_i \le y_i$。

这个递推式 $D_i = \max(D_{i-1} + t_{i-1}, x_i)$ 包含 $\max$ 操作，直接进行区间计算非常困难。我们需要将其转化为一个更易于数据结构维护的形式。

我们引入路径时间前缀和 $S_i = \sum_{k=1}^{i-1} t_k$ (令 $S_1 = 0$ )。
递推式可以展开：
$D_l = x_l$
$D_{l+1} = \max(D_l + t_l, x_{l+1}) = \max(x_l + t_l, x_{l+1})$
$D_{l+2} = \max(D_{l+1} + t_{l+1}, x_{l+2}) = \max(\max(x_l + t_l, x_{l+1}) + t_{l+1}, x_{l+2}) = \max(x_l + t_l + t_{l+1}, x_{l+1} + t_{l+1}, x_{l+2})$

观察这个展开式，我们可以发现规律：
$$D_i = \max_{j=l}^{i} (x_j + \sum_{k=j}^{i-1} t_k)$$

使用前缀和 $S_i$ 来简化 $\sum t_k$: $\sum_{k=j}^{i-1} t_k = S_i - S_j$。
$$D_i = \max_{j=l}^{i} (x_j + S_i - S_j) = S_i + \max_{j=l}^{i} (x_j - S_j)$$

现在，我们将成功条件 $D_i \le y_i$ 代入这个公式：
$$S_i + \max_{j=l}^{i} (x_j - S_j) \le y_i$$
$$\max_{j=l}^{i} (x_j - S_j) \le y_i - S_i$$

为了方便，我们定义两个新的量：
* $A_k = x_k - S_k$
* $B_k = y_k - S_k$

于是，查询 `0 l r` 的成功条件就等价于：
对于所有的 $i \in [l, r]$，都必须满足 $\max_{j=l}^{i} A_j \le B_i$。

## 数据结构选择

这个问题现在转化为一个带有复杂判定条件的区间查询问题，并且混合了两种更新操作：

* **操作1 (`1 p w`)**: 修改 $t_p$。这会导致 $S_i$ (对于所有 $i > p$) 发生变化，进而导致 $A_i$ 和 $B_i$ (对于所有 $i > p$) 发生区间性的平移。这是一个**区间更新**。
* **操作2 (`2 o a b`)**: 修改 $x_o, y_o$。这只会影响 $A_o$ 和 $B_o$。这是一个**单点更新**。

查询和更新操作都很频繁，并且数据量很大，这提示我们使用**线段树**。由于存在区间更新，我们需要一个支持**懒惰标记(Lazy Propagation)** 的线段树。

同时，为了在更新 $t_p$ 后能快速计算出任意 $S_o$ 的值 (操作2需要)，我们可以额外使用一个**树状数组 (Fenwick Tree)** 来维护 $t$ 数组的前缀和。

所以，最终的算法结构是：
1.  **树状数组**：维护 $t_i$ 的值，支持单点修改和前缀和查询。
2.  **线段树**：维护 $A_i$ 和 $B_i$ 的相关信息，并解决核心的区间查询问题。

## 线段树设计

线段树的每个节点需要存储什么信息，才能高效地合并并回答查询？
对于一个代表区间 $[a, b]$ 的线段树节点，我们需要存储：

1.  `ma`: 区间内 $A_k$ 的最大值，即 $\max_{k=a}^{b} A_k$。
2.  `mb`: 区间内 $B_k$ 的最小值，即 $\min_{k=a}^{b} B_k$。
3.  `ok`: 一个布尔标记，表示该区间内部是否满足查询条件。也就是说，对于所有 $i \in [a, b]$，是否都有 $\max_{j=a}^{i} A_j \le B_i$。
4.  `lz`: 懒惰标记，用于区间更新。

### 节点合并 (pushup)

假设要合并左子节点 L (区间 $[a, m]$) 和右子节点 R (区间 $[m+1, b]$) 到父节点 P。

* $P.ma = \max(L.ma, R.ma)$
* $P.mb = \min(L.mb, R.mb)$
* `P.ok` 的计算最为关键。要使 P 区间 $[a, b]$ 整体满足条件，需要：
    1.  左子区间 $[a, m]$ 内部满足条件，即 `L.ok` 为 `true`。
    2.  右子区间 $[m+1, b]$ 内部满足条件，即 `R.ok` 为 `true`。
    3.  对于右子区间中的任意点 $i \in [m+1, b]$，$\max_{j=a}^{i} A_j \le B_i$ 必须成立。这可以分解为 $\max(\max_{j=a}^{m} A_j, \max_{j=m+1}^{i} A_j) \le B_i$。这要求左子区间的最大值 `L.ma` 不能超过右子区间任意一点的 $B_i$，即 `L.ma` 不能超过右子区间的最小值 `R.mb`。
因此，$P.ok = L.ok \ \&\&\ R.ok \ \&\&\ (L.ma \le R.mb)$。

### 区间查询 ( doQuery ):

对于查询 `0 l r`，我们需要检查 $\forall i \in [l, r], \max_{j=l}^{i} A_j \le B_i$。
我们可以写一个递归函数，在遍历线段树区间 $[l, r]$ 的同时，维护一个变量 `current_ma`，记录查询区间内已经遍历过的部分的 $A_j$ 最大值。当进入一个新的子区间时，用 `current_ma` 和该区间的 `mb`、`ok` 标志进行判断。

### 更新操作：

* **操作1 (`1 p w`)**: $t_p$ 变为 $w$，变化量为 $\Delta = w - t_p^{old}$。对于所有 $i > p$，$S_i$ 增加 $\Delta$，因此 $A_i$ 和 $B_i$ 都会减小 $\Delta$。我们对线段树的 $[p+1, n]$ 区间进行一次值为 $-\Delta$ 的区间更新。
* **操作2 (`2 o a b`)**: $x_o, y_o$ 变为 $a, b$。我们用树状数组查询出当前的 $S_o$，然后计算出新的 $A_o, B_o$，对线段树进行一次单点更新。

这个算法的时间复杂度为 $O((N + Q)\log N)$，足以通过本题。

## C++ 代码实现

以下是根据上述思路实现的C++代码，严格遵守了格式要求。

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

// 使用 using namespace std 是一个常见的竞赛编程习惯，但在大型项目中可能不被推荐
using namespace std;

// 定义一个非常大的数作为无穷大，用于比较
const long long INF = 4e18; 

// 线段树节点的结构体定义
struct Node {
  long long ma; // 区间内 max(x_k - s_k) 的值
  long long mb; // 区间内 min(y_k - s_k) 的值
  long long lz; // 懒惰标记，用于区间更新
  bool ok;      // 区间内部是否满足条件的标志
};

// --- 全局变量 ---
// 这些变量在每个测试用例中都会被重新初始化
int n; // 顾客数量
vector<long long> x, y, t; // 输入数据：x, y 时间窗口，t 路上时间
vector<Node> tree; // 线段树
vector<long long> bit; // 树状数组，用于快速计算 t 的前缀和

// --- 树状数组 (Fenwick Tree) 函数 ---

/**
 * @brief 更新树状数组中某个位置的值
 * @param idx 要更新的位置 (1-based)
 * @param dlt 值的变化量
 */
void bitUpdate(int idx, long long dlt) {
  for (; idx < n; idx += idx & -idx) { // 遍历所有受影响的父节点
    bit[idx] += dlt; // 更新节点值
  }
}

/**
 * @brief 查询树状数组的前缀和
 * @param idx 要查询的位置 (0-based for t, so query up to idx)
 * @return t_1 + ... + t_idx 的和
 */
long long bitQuery(int idx) {
  long long sum = 0; // 初始化和为 0
  for (; idx > 0; idx -= idx & -idx) { // 遍历所有相关的父节点
    sum += bit[idx]; // 累加节点值
  }
  return sum; // 返回总和
}

// --- 线段树函数 ---

/**
 * @brief 合并两个子节点的信息到父节点
 * @param p 父节点的索引
 */
void pushUp(int p) {
  tree[p].ma = max(tree[p * 2].ma, tree[p * 2 + 1].ma); // 父节点的 ma 是两个子节点 ma 的最大值
  tree[p].mb = min(tree[p * 2].mb, tree[p * 2 + 1].mb); // 父节点的 mb 是两个子节点 mb 的最小值
  // 父节点 ok 的条件：左右子节点都 ok，并且左子树的 ma 不大于右子树的 mb
  tree[p].ok = tree[p * 2].ok && tree[p * 2 + 1].ok && (tree[p * 2].ma <= tree[p * 2 + 1].mb);
}

/**
 * @brief 将父节点的懒惰标记下推到子节点
 * @param p 父节点的索引
 */
void pushDown(int p) {
  if (tree[p].lz != 0) { // 如果存在懒惰标记
    long long dlt = tree[p].lz; // 获取懒惰标记的值
    tree[p * 2].lz += dlt; // 将标记传递给左子节点
    tree[p * 2].ma += dlt; // 更新左子节点的 ma
    tree[p * 2].mb += dlt; // 更新左子节点的 mb
    tree[p * 2 + 1].lz += dlt; // 将标记传递给右子节点
    tree[p * 2 + 1].ma += dlt; // 更新右子节点的 ma
    tree[p * 2 + 1].mb += dlt; // 更新右子节点的 mb
    tree[p].lz = 0; // 清除父节点的懒惰标记
  }
}

/**
 * @brief 构建线段树
 * @param p 当前节点索引
 * @param l 当前节点代表的区间的左端点
 * @param r 当前节点代表的区间的右端点
 */
void build(int p, int l, int r) {
  tree[p].lz = 0; // 初始化懒惰标记
  if (l == r) { // 如果是叶子节点
    long long sl = bitQuery(l - 1); // 查询 s_l
    tree[p].ma = x[l] - sl; // 计算并存储 ma
    tree[p].mb = y[l] - sl; // 计算并存储 mb
    tree[p].ok = true; // 叶子节点自身总是满足条件的
    return;
  }
  int mid = l + (r - l) / 2; // 计算中间点，防止溢出
  build(p * 2, l, mid); // 递归构建左子树
  build(p * 2 + 1, mid + 1, r); // 递归构建右子树
  pushUp(p); // 合并子节点信息
}

/**
 * @brief 单点更新 (操作类型 2)
 * @param p 当前节点索引
 * @param l, r 当前节点代表的区间
 * @param pos 要更新的位置
 * @param s_pos pos 位置的 s 值 (s_pos = t_1 + ... + t_{pos-1})
 */
void updateVal(int p, int l, int r, int pos, long long s_pos) {
  if (l == r) { // 找到叶子节点
    tree[p].ma = x[pos] - s_pos; // 根据新的 x, y 和 s 值更新 ma
    tree[p].mb = y[pos] - s_pos; // 更新 mb
    return;
  }
  pushDown(p); // 下推懒惰标记
  int mid = l + (r - l) / 2; // 计算中间点
  if (pos <= mid) { // 如果目标位置在左子树
    updateVal(p * 2, l, mid, pos, s_pos); // 递归更新左子树
  } else { // 如果目标位置在右子树
    updateVal(p * 2 + 1, mid + 1, r, pos, s_pos); // 递归更新右子树
  }
  pushUp(p); // 向上合并更新结果
}

/**
 * @brief 区间更新 (操作类型 1)
 * @param p 当前节点索引
 * @param l, r 当前节点代表的区间
 * @param ul, ur 要更新的区间
 * @param val 更新的值
 */
void updateRng(int p, int l, int r, int ul, int ur, long long val) {
  if (ul > ur) return; // 如果更新区间无效，则直接返回
  if (ul <= l && r <= ur) { // 如果当前区间被更新区间完全覆盖
    tree[p].lz += val; // 更新懒惰标记
    tree[p].ma += val; // 直接更新 ma
    tree[p].mb += val; // 直接更新 mb
    return;
  }
  pushDown(p); // 下推懒惰标记
  int mid = l + (r - l) / 2; // 计算中间点
  if (ul <= mid) { // 如果更新区间与左子区间有交集
    updateRng(p * 2, l, mid, ul, ur, val); // 递归更新左子树
  }
  if (ur > mid) { // 如果更新区间与右子区间有交集
    updateRng(p * 2 + 1, mid + 1, r, ul, ur, val); // 递归更新右子树
  }
  pushUp(p); // 向上合并更新结果
}

/**
 * @brief 区间查询 (操作类型 0)
 * @param p 当前节点索引
 * @param l, r 当前节点代表的区间
 * @param ql, qr 要查询的区间
 * @param cma 引用传递，记录查询范围内左侧部分的 ma 最大值
 * @return 区间是否满足条件
 */
bool doQuery(int p, int l, int r, int ql, int qr, long long& cma) {
  if (r < ql || l > qr) { // 如果查询区间与当前节点无交集
    return true; // 返回 true，不影响结果
  }
  if (ql <= l && r <= qr) { // 如果当前节点被查询区间完全覆盖
    if (cma > tree[p].mb) { // 如果左侧的最大 ma 已经大于当前区间的最小 mb
      return false; // 则不满足条件
    }
    if (!tree[p].ok) { // 如果当前区间内部本身就不满足条件
      return false; // 则不满足条件
    }
    cma = max(cma, tree[p].ma); // 更新 cma 为当前已遍历区间的 ma 最大值
    return true; // 当前节点检查通过
  }
  pushDown(p); // 下推懒惰标记
  int mid = l + (r - l) / 2; // 计算中间点
  if (!doQuery(p * 2, l, mid, ql, qr, cma)) { // 查询左子树
    return false; // 如果左子树查询失败，则整体失败
  }
  if (!doQuery(p * 2 + 1, mid + 1, r, ql, qr, cma)) { // 查询右子树
    return false; // 如果右子树查询失败，则整体失败
  }
  return true; // 左右子树都查询成功
}

/**
 * @brief 处理单个测试用例的主函数
 */
void solve() {
  cin >> n; // 读入顾客数

  // 根据 n 调整所有 vector 的大小
  x.assign(n + 1, 0);
  y.assign(n + 1, 0);
  t.assign(n, 0);
  tree.assign(n * 4 + 5, Node());
  bit.assign(n + 1, 0);

  for (int i = 1; i <= n; ++i) cin >> x[i]; // 读入 x 数组
  for (int i = 1; i <= n; ++i) cin >> y[i]; // 读入 y 数组
  for (int i = 1; i < n; ++i) cin >> t[i]; // 读入 t 数组

  // 初始化树状数组
  for (int i = 1; i < n; ++i) {
    bitUpdate(i, t[i]); // 将 t 的值加入树状数组
  }

  build(1, 1, n); // 构建线段树

  int q;
  cin >> q; // 读入查询次数
  while (q--) {
    int type;
    cin >> type; // 读入操作类型
    if (type == 0) {
      int l, r;
      cin >> l >> r; // 读入查询区间 [l, r]
      if (l > r) { // 如果 l > r 是一个空区间
        cout << "Yes\n"; // 总是合法的
        continue;
      }
      long long cma = -INF; // 初始化当前最大 ma 为负无穷
      if (doQuery(1, 1, n, l, r, cma)) { // 执行查询
        cout << "Yes\n"; // 如果合法
      } else {
        cout << "No\n"; // 如果不合法
      }
    } else if (type == 1) {
      int p;
      long long w;
      cin >> p >> w; // 读入更新位置 p 和新值 w
      long long dlt = w - t[p]; // 计算 t[p] 的变化量
      t[p] = w; // 更新 t 数组
      bitUpdate(p, dlt); // 在树状数组中更新 t[p]
      updateRng(1, 1, n, p + 1, n, -dlt); // 对 [p+1, n] 区间进行更新
    } else { // type == 2
      int o, a, b;
      cin >> o >> a >> b; // 读入更新位置 o 和新值 a, b
      x[o] = a; // 更新 x 数组
      y[o] = b; // 更新 y 数组
      long long s_o = bitQuery(o - 1); // 查询 s_o 的当前值
      updateVal(1, 1, n, o, s_o); // 在线段树中进行单点更新
    }
  }
}

/**
 * @brief 程序主入口
 */
int main() {
  // 加速 C++ IO
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);

  int T;
  cin >> T; // 读入测试数据组数
  while (T--) {
    solve(); // 循环处理每个测试用例
  }
  return 0; // 程序正常退出
}
```